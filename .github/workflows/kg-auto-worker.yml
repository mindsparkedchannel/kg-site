name: kg-auto-worker

on:
  workflow_dispatch:
    inputs:
      DRY_RUN:
        description: "Nur simulieren"
        type: boolean
        required: false
        default: true
      MAX_ISSUES:
        description: "Max. zu verarbeitende Issues"
        type: number
        required: false
        default: 5
  schedule:
    - cron: "0 * * * *" # stÃ¼ndlich; bei Bedarf entfernen

permissions:
  issues: write
  contents: read

env:
  LABEL_INBOX:  kg-inbox
  LABEL_RUN:    kg-running
  LABEL_DONE:   kg-done
  # FÃ¼r den Mirror-Dispatch:
  OWNER_SITE:   ${{ vars.GITHUB_OWNER_SITE }}
  REPO_SITE:    ${{ vars.GITHUB_REPO_SITE }}
  DISPATCH_PAT: ${{ secrets.REPO_DISPATCH }}

jobs:
  process-inbox:
    runs-on: ubuntu-latest
    steps:
      - name: Process kg-inbox â†’ kg-done (Dry-Run aware, with Backoff)
        uses: actions/github-script@v7
        with:
          script: |
            const core = require('@actions/core');
            const {owner, repo} = context.repo;

            // Inputs robust lesen (funktioniert mit workflow_dispatch; bei schedule greifen Defaults/ENV)
            const dry  = (core.getInput('DRY_RUN') || process.env.DRY_RUN || 'false').toLowerCase() === 'true';
            const maxN = parseInt(core.getInput('MAX_ISSUES') || process.env.MAX_ISSUES || '5', 10);

            const LABEL_INBOX = process.env.LABEL_INBOX || 'kg-inbox';
            const LABEL_RUN   = process.env.LABEL_RUN   || 'kg-running';
            const LABEL_DONE  = process.env.LABEL_DONE  || 'kg-done';

            async function backoff(fn, tries=5){
              let d=1000;
              for(let i=1;i<=tries;i++){
                try { return await fn(); } catch(e){
                  if(i===tries) throw e;
                  await new Promise(r=>setTimeout(r,d));
                  d=Math.min(d*2,30000);
                }
              }
            }

            // Kandidaten holen
            let all = await backoff(()=>github.paginate(github.rest.issues.listForRepo, {
              owner, repo, state:'open', labels: LABEL_INBOX, sort:'created', direction:'asc', per_page:100
            }));
            let issues = all.filter(x => !x.pull_request).slice(0, maxN);

            core.summary.addHeading('kg-auto-worker');
            core.summary.addRaw(`dry=${dry} maxN=${maxN} candidates=${issues.length}\n`);

            for(const it of issues){
              const num = it.number;
              const existing = it.labels.map(l => typeof l === 'string' ? l : l.name);

              // â†’ running
              await backoff(()=>github.rest.issues.addLabels({ owner, repo, issue_number:num, labels:[LABEL_RUN] }));
              await backoff(()=>github.rest.issues.removeLabel({ owner, repo, issue_number:num, name: LABEL_INBOX }).catch(()=>{}));

              if(dry){
                await backoff(()=>github.rest.issues.createComment({
                  owner, repo, issue_number:num, body:'ðŸ¤– [dry-run] geprÃ¼ft; keine Ã„nderung persistiert.'
                }));
                // zurÃ¼ckrollen
                await backoff(()=>github.rest.issues.removeLabel({ owner, repo, issue_number:num, name: LABEL_RUN }).catch(()=>{}));
                await backoff(()=>github.rest.issues.addLabels({ owner, repo, issue_number:num, labels:[LABEL_INBOX] }));
              } else {
                // â†’ done
                const keep = existing.filter(n => n !== LABEL_INBOX && n !== LABEL_RUN && n !== LABEL_DONE);
                const newLabels = Array.from(new Set([...keep, LABEL_DONE]));
                await backoff(()=>github.rest.issues.update({ owner, repo, issue_number:num, labels:newLabels }));
                await backoff(()=>github.rest.issues.removeLabel({ owner, repo, issue_number:num, name: LABEL_RUN }).catch(()=>{}));
                await backoff(()=>github.rest.issues.createComment({
                  owner, repo, issue_number:num, body:'ðŸ¤– processed â†’ **kg-done** âœ…'
                }));
              }
              core.info(`#${num} processed`);
            }

            await core.summary.write();

      - name: repository_dispatch â†’ kg-site (brain-sync)
        # nur wenn PAT/Owner/Repo gesetzt sind und NICHT im Dry-Run (bei schedule gibt es keine Inputs â†’ dann "scharf")
        if: ${{ env.DISPATCH_PAT != '' && env.OWNER_SITE != '' && env.REPO_SITE != '' && (github.event_name != 'workflow_dispatch' || inputs.DRY_RUN == 'false') }}
        run: |
          set -e
          echo "Dispatch to ${OWNER_SITE}/${REPO_SITE} (brain-sync)..."
          curl -sS -X POST \
            -H "Authorization: token ${DISPATCH_PAT}" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/repos/${OWNER_SITE}/${REPO_SITE}/dispatches \
            -d "{\"event_type\":\"brain-sync\",\"client_payload\":{\"reason\":\"auto-worker\",\"ts\":$(date +%s)}}"
          echo "[OK] repository_dispatch sent"
